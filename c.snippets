#templates
snippet template hello world
	#include <stdio.h>

	int main(int argc, char *argv[])
	{
		printf("Hello World\n");
		return 0;
	}
snippet template SDL2
	#include <SDL2/SDL.h>
	#include <SDL2/SDL_image.h>
	#include <SDL2/SDL_ttf.h>

	#include <time.h>

	#define WIDTH 640
	#define HEIGHT 480

	#define FPS_FONT "Sans.ttf"
	#define FPS_SIZE 12

	const double FPS = 60;

	int init();
	SDL_Texture *init_fps_tex(TTF_Font *font, uint64_t frames,
			uint32_t tp, SDL_Renderer *ren);
	void render_fps(SDL_Renderer *ren, SDL_Texture *fps_tex);

	int main(int argc, char *argv[])
	{
		SDL_Window *win = NULL;
		SDL_Renderer *ren = NULL;
		SDL_Texture *fps = NULL;

		TTF_Font *font = NULL;
		SDL_Event e;
		SDL_bool running = SDL_TRUE;

		uint32_t st = 0, ttp = 0;
		uint32_t fst = 0, ftp = 0;
		frames = 0;

		if(!init()) return 1;

		win = SDL_CreateWindow("${1:WindowTitle}",
				0, 0, WIDTH, HEIGHT, SDL_WINDOW_SHOWN);
		if(!window)
		{
			fprintf(stderr, "fail to create SDL window, error: %s\n",
					SDL_GetError());
			return 1;
		}

		ren = SDL_CreateRenderer(window, -1,
				SDL_RENDERER_ACCELERATED);
		if(!renderer)
		{
			fprintf(stderr, "fail to create SDL renderer, error: %s\n",
					SDL_GetError());
			SDL_DestroyWindow(window);
			return 1;
		}

		font = TTF_OpenFont(FPS_FONT, FPS_SIZE);
		if(!font)
		{
			fprintf(stderr, "fail to open TTF font, error: %s\n",
					TTF_GetError());
			SDL_DestroyWindow(window);
			SDL_DestroyRenderer(renderer);
			return 1;
		}

		fps = init_fps_tex(font, frames, ttp, ren);
		if(!fps)
		{
			fprintf(stderr, "fail to create fps texture, error: %s\n",
					SDL_GetError());
			SDL_DestroyWindow(window);
			SDL_DestroyRenderer(renderer);
			TTF_CloseFont(font);
			return 1;
		}

		// main loop
		while(running)
		{
			fst = SDL_GetTicks();
			while(SDL_PollEvent(&e))
			{
				if(e.type == SDL_QUIT)
					running = SDL_FALSE;
			}

			// update
			frames ++;
			if(frames == 0) st = 0;

			ttp = SDL_GetTicks() - st;
			if(fps) SDL_DestroyTexture(fps);
			fps = init_fps_tex(font, frames, ttp, ren);

			// render
			SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
			SDL_RenderClear(renderer);
			// fps
			render_fps_texture(renderer, fps);
			// wall
			SDL_SetRenderDrawColor(renderer, 0, 124, 255, 0);
			SDL_RenderFillRect(renderer, &wall);
			// objects
			SDL_SetRenderDrawColor(renderer, 77, 202, 77, 0);
			for(i = 0 ; i < OBJ_NUM ; i ++)
				SDL_RenderFillRect(renderer, &objects[i]);
			SDL_RenderPresent(renderer);
			// end of rendering

			frame_time_passed = SDL_GetTicks() - frame_start_time;
			if(frame_time_passed < 1000 / FPS)
				SDL_Delay(1000 / FPS - frame_time_passed);
		}

		SDL_DestroyWindow(window);
		SDL_DestroyRenderer(renderer);
		SDL_DestroyTexture(fps);
		TTF_CloseFont(font);
		return 0;
	}

	int init()
	{
		const int IMG_FLAG =
				IMG_INIT_PNG | IMG_INIT_TIF | IMG_INIT_JPG;
		if(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO))
		{
			fprintf(stderr, "fail to initialize SDL, error: %s\n",
					SDL_GetError());
			return 0;
		}
		atexit(SDL_Quit);
		if((IMG_Init(IMG_FLAG) & IMG_FLAG) != IMG_FLAG)
		{
			fprintf(stderr, "fail to initialize IMG, error: %s\n",
					SDL_GetError());
			return 0;
		}
		atexit(IMG_Quit);
		if(TTF_Init() == -1)
		{
			fprintf(stderr, "fail to initialize TTF, error: %s\n",
					SDL_GetError());
			return 0;
		}
		atexit(TTF_Quit);
		return 1;
	}

	SDL_Texture *create_fps_texture(TTF_Font *font, long long int frames, Uint32 time_passed,
			SDL_Renderer *renderer)
	{
		SDL_Surface *surf = NULL;
		SDL_Texture *texture = NULL;
		const SDL_Color text_color = {255, 255, 255, 255};
		const int str_size = 256;
		char str[str_size];

		memset(str, '\0', str_size);
		if(time_passed == 0)
			sprintf(str, "FPS: --");
		else
			sprintf(str, "FPS: %.2lf", (double) frames / time_passed * 1000);

		surf = TTF_RenderText_Blended(font, str, text_color);
		if(!surf)
		{
			fprintf(stderr, "fail to render TTF text, error: %s\n", TTF_GetError());
			return NULL;
		}

		texture = SDL_CreateTextureFromSurface(renderer, surf);
		if(!texture)
		{
			fprintf(stderr, "fail to create texture from surface, error: %s\n", SDL_GetError());
			SDL_FreeSurface(surf);
		}

		SDL_FreeSurface(surf);
		return texture;
	}

	void render_fps_texture(SDL_Renderer *renderer, SDL_Texture *texture)
	{
		SDL_Rect dst;

		SDL_QueryTexture(texture, NULL, NULL, &dst.w, &dst.h);
		dst.x = WINDOW_WIDTH - 65;
		dst.y = 0;
		SDL_RenderCopy(renderer, texture, NULL, &dst);
	}

	SDL_bool is_colliding_with(SDL_Rect obj, SDL_Rect wall)
	{
		if(obj.x <= wall.x + wall.w &&
			obj.x + obj.w >= wall.x &&
			obj.y <= wall.y + wall.h &&
			obj.y + obj.h >= wall.y)
			return SDL_TRUE;
		return SDL_FALSE;
	}

# main()
snippet main
	int main(int argc, char *argv[])
	{
		${1}
		return 0;
	}
# #include <...>
snippet in
	#include <${1:stdio}.h>${2}
snippet inc
	#include <${1:stdio}.h>${2}
snippet incl
	#include <${1:stdio}.h>${2}
snippet inclu
	#include <${1:stdio}.h>${2}
snippet includ
	#include <${1:stdio}.h>${2}
snippet include
	#include <${1:stdio}.h>${2}
# #include "..."
snippet Inc
	#include "${1:`Filename("$1.h")`}"${2}
snippet Incl
	#include "${1:`Filename("$1.h")`}"${2}
snippet Inclu
	#include "${1:`Filename("$1.h")`}"${2}
snippet Includ
	#include "${1:`Filename("$1.h")`}"${2}
snippet Include
	#include "${1:`Filename("$1.h")`}"${2}
# #ifndef ... #define ... #endif
snippet De
	#ifndef $1
	#define ${1:SYMBOL} ${2:value}
	#endif${3}
snippet Def
	#ifndef $1
	#define ${1:SYMBOL} ${2:value}
	#endif${3}
snippet Defi
	#ifndef $1
	#define ${1:SYMBOL} ${2:value}
	#endif${3}
snippet Defin
	#ifndef $1
	#define ${1:SYMBOL} ${2:value}
	#endif${3}
snippet Define
	#ifndef $1
	#define ${1:SYMBOL} ${2:value}
	#endif${3}
# #define
snippet de
	#define 
snippet def
	#define 
snippet defi
	#define 
snippet defin
	#define 
snippet define
	#define 
snippet #d
	#define 
snippet #de
	#define 
snippet #def
	#define 
snippet #defi
	#define 
snippet #defin
	#define 
# ifdef
snippet ifdef
	#ifdef ${1:FOO}
		${2:#define }
	#endif
snippet #if
	#if ${1:FOO}
		${2}
	#endif
# Header Include-Guard
# (the randomizer code is taken directly from TextMate; it could probably be
# cleaner, I don't know how to do it in vim script)
snippet once
	#ifndef ${1:`toupper(Filename('', 'UNTITLED').'_'.system("/usr/bin/ruby -e 'print (rand * 2821109907455).round.to_s(36)'"))`}
	#define $1
	${2}

	#endif /* end of include guard: $1 */
# If Condition
snippet if
	if(${1:/* condition */})
	{
		${2:/* code */}
	}
snippet el
	else
	{
		${1}
	}
snippet els
	else
	{
		${1}
	}
snippet else
	else
	{
		${1}
	}
# Tertiary conditional
snippet t
	${1:/* condition */} ? ${2:a} : ${3:b}
# Do While Loop
snippet do
	do
	{
		${2:/* code */}
	} while (${1:/* condition */});
# While Loop
snippet wh
	while(${1:/* condition */})
	{
		${2:/* code */}
	}
snippet whi
	while(${1:/* condition */})
	{
		${2:/* code */}
	}
snippet whil
	while(${1:/* condition */})
	{
		${2:/* code */}
	}
snippet while
	while(${1:/* condition */})
	{
		${2:/* code */}
	}
# For Loop
snippet fo
	for(${1:i} = ${2:0}; ${3:$1 < 10}; $1 ${4:++})
	{
		${5:/* code */}
	}
snippet for
	for(${1:i} = ${2:0}; ${3:$1 < 10}; $1 ${4:++})
	{
		${5:/* code */}
	}
# Custom For Loop
snippet forr
	for(${1:i} = 0 ; $1 < ${2:count} ; $1 ${3:++})
	{
		${4:/* code */}
	}
# switch case
snippet sw
	switch(${1:variable})
	{
	case ${2:1}:
		break;
	}$3
snippet swi
	switch(${1:variable})
	{
	case ${2:1}:
		break;
	}$3
snippet swit
	switch(${1:variable})
	{
	case ${2:1}:
		break;
	}$3
snippet switc
	switch(${1:variable})
	{
	case ${2:1}:
		break;
	}$3
snippet switch
	switch(${1:variable})
	{
	case ${2:1}:
		break;
	}$3
# Function Declaration
snippet fu
	${1:void} ${2:function_name}(${3:arguments});

	$1 $2($3)
	{
		${4:/* code */}
		return ${5};
	}
snippet fun
	${1:void} ${2:function_name}(${3});${4}

	$1 $2($3)
	{
		${4:/* code */}
		return ${5};
	}
snippet func
	${1:void} ${2:function_name}(${3});${4}

	$1 $2($3)
	{
		${4:/* code */}
		return ${5};
	}
snippet funct
	${1:void} ${2:function_name}(${3});${4}

	$1 $2($3)
	{
		${4:/* code */}
		return ${5};
	}
snippet functi
	${1:void} ${2:function_name}(${3});${4}

	$1 $2($3)
	{
		${4:/* code */}
		return ${5};
	}
snippet functio
	${1:void} ${2:function_name}(${3});${4}

	$1 $2($3)
	{
		${4:/* code */}
		return ${5};
	}
snippet function
	${1:void} ${2:function_name}(${3});${4}

	$1 $2($3)
	{
		${4:/* code */}
		return ${5};
	}
# Function Body
snippet funb
	${1:void} ${2:function_name}(${3})
	{
		${4:/* code */}
	}
# Typedef
snippet td
	typedef ${1:int} ${2:Type};${3}
snippet ty
	typedef ${1:int} ${2:Type};${3}
snippet typ
	typedef ${1:int} ${2:Type};${3}
snippet type
	typedef ${1:int} ${2:Type};${3}
snippet typed
	typedef ${1:int} ${2:Type};${3}
snippet typede
	typedef ${1:int} ${2:Type};${3}
snippet typedef
	typedef ${1:int} ${2:Type};${3}
# Typedef struct
snippet tds
	typedef struct ${2:_$1 }{
		${3:/* data */}
	} ${1:`Filename('$1_t', 'name')`};
snippet typedef s
	typedef struct ${2:_$1 }{
		${3:/* data */}
	} ${1:`Filename('$1_t', 'name')`};
snippet typedef st
	typedef struct ${2:_$1 }{
		${3:/* data */}
	} ${1:`Filename('$1_t', 'name')`};
snippet typedef str
	typedef struct ${2:_$1 }{
		${3:/* data */}
	} ${1:`Filename('$1_t', 'name')`};
snippet typedef stru
	typedef struct ${2:_$1 }{
		${3:/* data */}
	} ${1:`Filename('$1_t', 'name')`};
snippet typedef struc
	typedef struct ${2:_$1 }{
		${3:/* data */}
	} ${1:`Filename('$1_t', 'name')`};
snippet typedef struct
	typedef struct ${2:_$1 }{
		${3:/* data */}
	} ${1:`Filename('$1_t', 'name')`};
# Struct
snippet st
	struct ${1:`Filename('$1_t', 'name')`}
	{
		${2:/* data */}
	} ${3: /* optional variable list */};${4}
snippet str
	struct ${1:`Filename('$1_t', 'name')`}
	{
		${2:/* data */}
	} ${3: /* optional variable list */};${4}
snippet stru
	struct ${1:`Filename('$1_t', 'name')`}
	{
		${2:/* data */}
	} ${3: /* optional variable list */};${4}
snippet struc
	struct ${1:`Filename('$1_t', 'name')`}
	{
		${2:/* data */}
	} ${3: /* optional variable list */};${4}
snippet struct
	struct ${1:`Filename('$1_t', 'name')`}
	{
		${2:/* data */}
	} ${3: /* optional variable list */};${4}
# Typdef enum
snippet tde
	typedef enum
	{
		${1:/* data */}
	} ${2:foo};
snippet typedef e
	typedef enum
	{
		${1:/* data */}
	} ${2:foo};
snippet typedef en
	typedef enum
	{
		${1:/* data */}
	} ${2:foo};
snippet typedef enu
	typedef enum
	{
		${1:/* data */}
	} ${2:foo};
snippet typedef enum
	typedef enum
	{
		${1:/* data */}
	} ${2:foo};
# printf
snippet pr
	printf("${1}"${2});${3}
snippet pri
	printf("${1}"${2});${3}
snippet prin
	printf("${1}"${2});${3}
snippet print
	printf("${1}"${2});${3}
snippet printf
	printf("${1}"${2});${3}
snippet printf(
	printf("${1}"${2}
# scanf
snippet sc
	scanf("${1:%s}"${2});${3}
snippet sca
	scanf("${1:%s}"${2});${3}
snippet scan
	scanf("${1:%s}"${2});${3}
snippet scanf
	scanf("${1:%s}"${2});${3}
snippet scanf(
	scanf("${1:%s}"${2}
# fprintf
snippet fpr
	fprintf(${1:stderr}, "${2:%s}\n"${3});${4}
snippet fpri
	fprintf(${1:stderr}, "${2:%s}\n"${3});${4}
snippet fprin
	fprintf(${1:stderr}, "${2:%s}\n"${3});${4}
snippet fprint
	fprintf(${1:stderr}, "${2:%s}\n"${3});${4}
snippet fprintf
	fprintf(${1:stderr}, "${2:%s}\n"${3});${4}
snippet fprintf(
	fprintf(${1:stderr}, "${2:%s}\n"${3}
snippet {
	{
		${1:/* code */)
	
# unsigned 
snippet un
	unsigned
snippet uns
	unsigned
snippet unsi
	unsigned
snippet unsig
	unsigned
snippet unsign
	unsigned
snippet unsigne
	unsigned
# omp
snippet omp
	#pragma omp parallel
	{
		int id = omp_get_thread_num();
		${1}
	}
